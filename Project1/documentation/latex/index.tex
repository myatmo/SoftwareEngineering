\hypertarget{index_intro_sec}{}\doxysection{Introduction}\label{index_intro_sec}
This project as a whole focuses on developing a working voting system for two different election types, including thorough written documentation as well as functioning code to bring our solutions to life.

In IR election, candidates are ranked with data of the ballots imported as a C\+SV file. In O\+PL election, single candidates are voted for with data of the ballots imported as a C\+SV file.\hypertarget{index_overview_sec}{}\doxysection{Overview}\label{index_overview_sec}
\hypertarget{index_IR_subsec}{}\doxysubsection{I\+R Election}\label{index_IR_subsec}
The basic technical flow of the simulation as implemented in IR Election was as follows\+:
\begin{DoxyItemize}
\item An election was started from running the main file~\newline

\item A C\+SV file was loaded into the program and the election type is determined from the first line of the C\+SV file~\newline

\item Candidates are extracted and dynamically created as an object~\newline

\item Ballot data is then extracted from the C\+SV file and brought into the election.~\newline

\item In IR, each candidate is ranked. Depending on rank, a winner is determined by the highest rank.~\newline
 This implementation was actually already flexible enough to handle any ties that may occur by removing the lowest ranked candidate and recalculating a winner where votes from ballot data are then redistributed amongs the remaining candidates.~\newline
 A winner is then presented as output from the program, and the election is deleted.
\end{DoxyItemize}\hypertarget{index_OPL_subsec}{}\doxysubsection{O\+P\+L Election}\label{index_OPL_subsec}
The basic technical flow of the simulation as implemented in O\+PL Election was as follows\+:
\begin{DoxyItemize}
\item An election was started from running the main file~\newline

\item A C\+SV file was loaded into the program and the election type is determined from the first line of the C\+SV file~\newline

\item Candidates are extracted and dynamically created as an object~\newline

\item Ballot data is then extracted from the C\+SV file and brought into the election.~\newline

\item In O\+PL, each candidate has a vote count and each ballot holds exactly one vote for a single candidate.
\item The winner is determined by the candidate with the highest vote count once all ballots have been counted.~\newline
 This implementation was actually already flexible enough to handle any ties that may occur by calculating a winner based on a random coin toss.~\newline
 A winner is then presented as output from the program, and the election is deleted.
\end{DoxyItemize}\hypertarget{index_getting_started_sec}{}\doxysection{Getting Started}\label{index_getting_started_sec}
To test it out for yourself...~\newline
First, ensure that you are in the {\ttfamily /project} directory.~\newline
Once there, build and run\+: \begin{DoxyVerb} make
 ./votecount
\end{DoxyVerb}
 The system will ask for input on which type of election and then the file name. Ensure that the file is in the Project1/testing folder~\newline
A detailed audit will be created for each election and placed in Project1/src/\+Audits folder with the current date and time stamp~\newline
A summary of the results will be written over the Display\+Results.\+txt which can be shared with the media if saved elsewhere before running an additional election~\newline
The timing constraint will be printed to the terminal as well as additional summary of the election.~\newline
 \hypertarget{index_test_sub}{}\doxysubsection{Testing the Classes}\label{index_test_sub}
You can test the class methods by navigating to Project1/src/\+Unit\+Tests~\newline
Once there, build a run\+: \begin{DoxyVerb} make
 ./test
\end{DoxyVerb}
 You can save a record of these tests by inputing ./test $>$$>$ ../../testing/testinglogs.txt~\newline
DO N\+OT U\+SE $>$ AS T\+H\+IS W\+I\+LL O\+V\+E\+R\+W\+R\+T\+IE E\+X\+I\+S\+T\+I\+NG T\+E\+ST R\+E\+C\+O\+R\+D\+S! 